---
category:
  - RA2
  - 地图
tag:
  - 地图编辑
  - 触发
  - 局部变量
star: true
---

# 红警 2 地图触发组件的逻辑原理

::: warning 观前注意
这篇是有意按照我的毕业论文编排去撰写的。并且由于涉及一些编程知识点，可能存在亿些阅读困难。
虽然经过与 Zero Fanker 等人的讨论后决定做些修缮，但难免仍有需要改进之处。
:::

## 绪言

红警 2 的地图创作，但凡要实现一些功能，首先会想到的必然是触发和 INI。
特别是单人战役和多人合作战役，离开了触发，剧情流程也就荡然无存^1^，其本质便只剩下遭遇战了。

然而，大部分的地图创作者们由于缺乏对触发比较明晰的认识，圈子里的教程也往往偏实用主义，
他们经常是「知其然而不知其所以然」，若需要加入稍微复杂一点的流程设计，往往束手无策。

我们已知一条基本哲理：复杂事物是若干简单事物的有机组合。由于触发与数学的「命题」——若 p 则 q——非常类似，
因此私以为从逻辑层面剖析触发的运行原理对于复杂触发的设计应能起到一定指导作用，
并与`Ares` `Phobos`等扩展平台一道为我们展现出`gamemd.exe`这个古董的更多可能性。

## 一、触发组件相关概念

### 1.1 触发

地图触发是早在《命运与征服：泰伯利亚黎明》就引入的系统，负责处理地图当中的「事件」^1^。

一局游戏瞬息万变，其中总有一些**既成的、游戏引擎能感知的事，叫做事件**。比如什么关键建筑被打爆了啊，哪家缺电缺钱了，等等。
这些事件会被触发捕捉到，并驱动后者去执行相应的**行为，也就是游戏引擎能做到的各种效果**：可以是刷兵，改变光照，炸个桥，平地起心灵信标……诸如此类。

再次强调，捕获到的事件、要执行的行为，都仅限**引擎能做到的**范围之内。
你不能张口就要求给 20 多年前的游戏引擎加多核优化，引擎也只能表示：臣妾做不到啊。

::: note 事件和行为
有一些地编调整过用词，事件改称「条件」，行为改叫「结果」。你可以简单这么理解。
:::

在红警 2，触发更类似于数学中的命题：若 p 则 q，其中事件 p 和行为 q 都可以不止一条，并且 p1 p2 p... 之间、q1 q2 q... 之间有一定的连接关系。

### 1.2 局部变量

变量系统则在《命运与征服：泰伯利亚之日》才开始出现，根据`[VariableNames]`小节所处的位置不同，
分为 Rules 里的**全局变量**，和地图里的**局部变量**^2^。本文主要讨论局部变量。

在地图创作中，局部变量就是**对设计者有具体意义的**，**会因触发**（和动作脚本）**做出改变的**，**临时在某一局游戏起作用的**数值。

值得一提的是，从原版一直到 Ares 扩展平台，局部变量均有**上限 100 个**、`bool`**类型的限制**。  
直到 [@secsome](https://github.com/secsome) 在 Phobos 平台引入了无限量`int32`扩展局部变量，这种限制才被打破。

> 参考链接：
> [pr#321](https://github.com/Phobos-developers/Phobos/pull/321),
> [pr#424](https://github.com/Phobos-developers/Phobos/pull/424),
> [pr#425](https://github.com/Phobos-developers/Phobos/pull/425).

::: info 数值类型
现如今使用局部变量时需要关注以下三种类型：
- `bool`：布尔（所谓开关）。原版只有`0`（清除）和`1`（设置）两种情形；
- `int16`：短整数。**用于动作脚本**，范围`[-32768, 32767]`。出界不保证预期效果；
- `int32`：长整数。可以在**纯触发组件中使用**。范围`[-2147483648, 2147483647]`。

原理性的内容还请移步《计算机组成原理》第二章：数据的表示与运算。
:::

### 1.3 标签
标签负责告知游戏地图上存在的触发——对于未被任何标签引用的触发，游戏认为其不存在^3^。

通常来说，标签最直接的用途是**联结触发与地图上的实例**（科技类型、单元标记、作战小队），让触发去**判定关联对象的状态**（越过区域、对象被攻击/摧毁），或者去**赋予它们状态**（摧毁目标、变卖建筑）。此外，标签还**规定了触发的「重复类型」**——比如让触发循环提示任务目标。

::: note 科技类型
指代游戏中玩家可操作的东西，即步兵、载具、飞机和建筑。
再细分的话，从重工出来的飞行器（~~黄瓜~~基洛夫）、海里的船都算作载具；舰载机、V3 飞弹、空投机都算飞机。
:::

Zero Fanker 认为，标签是一种传递事件的「管道」，向触发传递关联对象的状态^4^。一旦触发成功接收到这个状态，**与管道断开了连接**，这个管道也就消亡。从这个角度出发，我们也可以这么说：那些未与尚存管道相连的触发，在游戏中全程空转；在用户（地图师和玩家）看来，就像是从未存在过。

## 二、触发组件的程序逻辑分析

> [!IMPORTANT]
> 本章的伪代码基于 Python 语法。考虑到现代编程语言的高级特性存在使用门槛，本章不会过分引入 Python 的语法和功能特性。

### 2.1 触发的逻辑本质

在程序语言里，有一种分支结构称为`if`用来描述上述的「若 p 则 q」：
```python
if condition:  # 条件
  do_something()  # 结果
```
这个`if`称作**条件单分支**。只有当条件`condition`满足（或者说为真），才会去走`do_something()`那一步，执行出结果来。

抛开触发的所属、难度开关等等其他属性，我们不妨就把一个触发当成是这种`if`结构。

> [!note]
> 为了方便讨论，本章「允许/禁止触发」不会直接使用`do_something()`这种函数表示。

至于事件`condition`和行为`do_something()`，我们已经知道它们可以不止一条。那么多条件和多结果是如何串起来的呢？
你可以自行翻阅各扩展平台的 YRpp，或是在 FA2 等地图编辑器中实验一下，这边就直接说结论了：

- 多个条件之间**以逻辑且（AND）连接**，所有条件**必须全部满足**，才可以执行对应的结果；
- 多个结果之间形成队列**按序执行**，但因为每一条结果执行耗时很短，表面上看似乎是同一帧内同时完成。

现在我们可以从程序逻辑上这么描述一个触发：
```python
if event1 and event2 and ...:
  action1()
  action2()
  ...
```

::: details 参考资料：触发行为在 INI 和引擎中的实际表示

以触发行为为例，触发行为在地图里是这种 INI 表示：
```ini
01019810 = len_actions, a1_type, a1p1, a1p2, ..., a1p6, a1_wp, a2_type, ...
```
在游戏引擎中，一条 Action 由`TActionClass`管理（下列声明有所省略，详见 [YRpp](https://github.com/Phobos-developers/YRpp/blob/c8d4da4f57a80a3cc2b9ecbde56c335e082c8335/TActionClass.h)）：
```cpp
class TActionClass : public AbstractClass {
public:
	TriggerAction      ActionKind;  // aX_type
	union {
		RectangleStruct    Bounds; // map bounds for use with action 40
		struct {
			int Param3;
			int Param4;
			int Param5;
			int Param6;
		};
	}; // It's enough for calling Bounds.X, just use a union here now. - secsome
	int                Waypoint;   // aX_wp
	int                Value2; // multipurpose  // aXp2
	int                Value; // multipurpose   // aXp1
};
```
其中 P1 决定了 P2 参数的类型。由于 P3-P6 均为`int`类型，无法满足文本、数值、触发等多种类型需求，所以由 Value (P1) 采取类似`enum`的设计，Value2 则记录真实参数 P2 的指针地址。
:::

::: details 参考资料：触发行为的具体实现
游戏引擎仍然用`TActionClass`声明和实现原版的行为（也就是地编靠前的 100 多号），扩展平台则用`TActionExt`实现扩展。
以 Phobos 的「编辑变量」功能为例：
```cpp
bool TActionExt::EditVariable(
  TActionClass* pThis, HouseClass* pHouse, ObjectClass* pObject,
  TriggerClass* pTrigger, CellStruct const& location)
{
  // blabla
  return true;
}
```
- `pThis`为`TActionClass`的指针，在参考资料「触发行为在 INI 和引擎中的实际表示」中已经介绍过，它可以记录行为参数；  
- `pHouse`系触发所属方，比如行为 36 - 全部更改所属 要变走\*触发所属方\*的全部东西。  

其余的函数形参我没有具体研究过，恕不做介绍。
:::

### 2.2 从程序执行流说起……

#### 2.2.1 顺序结构

顺序结构是最符合人类行为直觉的一种结构——我们办事喜欢讲究「按部就班」。在线性系统中，**按时间先后执行的流程**我们认为就是顺序结构^4^。

以被广为改编的「脑死」为例，它的任务流程具有很典型的顺序性：首先需要建立一座~~锅盖~~苏军雷达，然后打掉最后一座心灵控制器，最后秋风扫落叶。
实际上，早期大部分战役的剧情流程也是这种顺序结构——将目标从头执行到尾。

在程序当中最常见的莫过于这种顺序结构：
```python
x = 10
y = 4
print(x + y)
```
上面的代码中，**首先**令`x`等于 10，**接着**令`y`等于 4，**最后**在屏幕上给出`x + y`的结果。

> [!tip]
> 如果你在中学数学课上有学过程序框图（或者叫流程图），不妨画一个看看。

这样的「首先……接着……最后……」可以表明，上述语句是**逐条、自上而下执行**的，这就是程序中的**顺序结构**。

既然如此，我们不妨就把一整局战役当作这么一段程序代码。并且，我们已知了触发可以用`if`语句表示，那么实际上由触发主导的任务流程便可以看作是一个个`if`自上而下的排列：

```python
# [intro] 0. start
if AnyEvent:  # 8 - 任何事件（当*单独使用*时，它会令触发*立即执行*）
  lockInput()  # 46 - 禁止用户输入
  playSpeech("EVA_EstablishBattlefieldControl")  # 21 - 播放 EVA 语音

# [intro] 1. brief
if elapsedTime(6):  # 13 - 流逝时间
  textTrigger("mission:naosi_A")  # 11 - 文本触发
```

在上述的代码段中，我们可以看到有两个触发`[intro] 0. start`和`[intro] 1. brief`。  
其中，0 号触发的条件是`AnyEvent`。结合右边的注解和[前面](#_2-1-触发的逻辑本质)的分析，这个条件肯定是恒满足的，也就是为真（`True`）。这样触发先执行紧接的两行。  
我们知道这些代码段逐条、自上而下运行，而 1 号触发紧接在 0 号后面，说明 1 号需要**等待** 0 号执行了方可执行。结合顺序结构的定义，我们不难想到一个行为：53 - 允许触发。

大部分任务的设计大体上就是由「允许触发」串起来的流程链条。

#### 2.2.2 循环结构

注意到触发中有这么一个选项：重复类型。

![英文原版直接称作 Type，早期汉化也直接译作“类型”](fa2_trigger_ui.webp =65%x65%)

其中重复类型有以下三种取值（目前没有第四种！）

0. 任一（关联对象）满足事件，触发一次
1. 所有（关联对象）满足事件，触发一次
2. 任一（关联对象）满足事件，**重复**触发

可以看到，触发是有可能重复的。那么重复起来的触发长啥样呢？以最简单的开局无条件输出`Hello World`为例，将其改造为重复触发后，该触发会逐帧向屏幕的字幕区（一般在游戏左上角）打出文本。由于红警里 1 秒 = 15 帧，所以这个动作实际上非常快：
```
Hello World
Hello World
Hello Wor
Hello W
Hell
He
```
而在程序语言中，`while`循环则取代`if`扮演这个执行重复主体的角色：
```python
while True:
  print("Hello World")
```
将上述代码粘贴进 Python IDLE 回车运行，你也能看到终端里打出来一行行`Hello World`，除非用任务管理器干掉这个进程，否则它会无休止地输出下去。

分析这段代码不难发现，首先它走到`while True`处执行判断，由于条件恒满足，执行`print`；然后循环并没有结束，它重新回到`while`重复执行前面说的流程，将坏掉的乐土打字机事业推进下去~~爱莉希雅死辣~~。

「重复触发」也是类似的道理，一个「等待条件满足→执行结果」的循环。至此，我们可以用`while`循环表示一个重复触发了：
```python
while elapsedTime(6):  # 每隔 6 秒
  showText("Warning!")  # 输出文本
  spawnTeam("0X01BF52")  # 刷出臭援军（0x01bf52 = 114514）
```

#### 2.2.3 选择结构
在触发设计中，有的时候可能会希望在某一个节点，根据不同的情况分别做出不同的反应。这就涉及到了选择。选择结构是创建分支流程的重要组成部分，可用于实现**条件发生变化时流程也随之发生改变**的效果^4^。

在程序框图（或者说流程图）、程序代码中，最简单的双分支选择结构基于单个条件的真、假两种分支执行不同的处理：

![选择结构](https://image.woshipm.com/wp-files/2017/08/8Ynwb53uWeo9QMHb7Xi5.png =30%x30%)

当然也有基于不同条件的多分支结构。由于不同条件判断的时机不同，这种多分支也称作**决策树**：
```python
if delta < 0:
  print("该一元二次方程不存在实数根")
elif delta == 0:
  print("该方程存在两个相等实根{x1}")
else:
  print("解得 x1 = {x1}, x2 = {x2}")
```

但很遗憾，红警 2 

<!-- 
不如说，触发的选择结构更像是玩 GalGame 时的剧情分叉，或者说「选择肢」。通常来说，你选择了某一条分支，就沿着这条线一直走向结局（可能 BE 也可能 HE），并没有回头路。触发的选择也是同样的机制：**保留自身，排除异己**。

我们以“选中某个建筑，某建筑就刷漆归我，但只能选一个建筑”这个例子为例。那么自然地，我们先把“选中刷漆”的功能做出来。
```c
if (ObjectSelected(pObject_A)) {   // 事件 36 - 被玩家选中（注意，多人合作任务不可用）
  ChangeOwner(pObject_A, houseid); // 行为 14 - 更改（关联对象）所属（至特定所属方）
}
if (ObjectSelected(pObject_B)) {
  ChangeOwner(pObject_B, houseid);
}
if (ObjectSelected(pObject_C)) {
  ChangeOwner(pObject_C, houseid);
}
```
接下来就是选择了。既然同一帧内不可能点两个建筑，那么我们完全可以趁你改某一个建筑所属的时候，把其他改所属的触发给 ban 掉。
（下面的代码为了演示方便，改用 Python 写法）
```python
def selection_getA():   # 只是一条触发声明
  if ObjectSelected(pA):
    ChangeOwner(pA, houseID)
    del selection_getB  # 行为 12 - 摧毁触发事件
    del selection_getC
  return True

def selection_getB():
  if ObjectSelected(pB):
    ChangeOwner(pB, houseID)
    del selection_getA
    del selection_getC
  return True

def selection_getC():
  if ObjectSelected(pC):
    ChangeOwner(pC, houseID)
    del selection_getA
    del selection_getB
  return True
```
如果你需要像 GalGame 那样表达一种「除了 SL 没有回头路可选」的决绝，那么最好还是用行为 12；
而若是用行为 54 - 禁止触发，那么别的分支仍有可能在后续流程中「死灰复燃」。 -->

### 2.3 触发的时序关系

前面基于程序代码论述了触发在不同执行流中的逻辑表现，但实际上，触发并不总是这么「循规蹈矩」。两个触发之间其实并没有特别明显的制约关系，同一帧内其实也允许两条触发同时执行。

事实上，许多 UI 程序和 web 程序对于这种触发器的设计是异步的：你在点了某个按钮之后程序会执行一些业务，但这不应该影响你去操作别的按钮。触发也一样。

#### 2.3.1 时序基本原则

若没有特别限定，**默认的触发是未被阻塞**（也就是地编里未勾选「禁止」触发）、**所有难度都可以执行的**。这种情况下，它**从开局就开始等待事件**（或者说判断条件），一旦有这么一个事件（组）（或者说条件（组）满足），它就执行相应的行为。

**如果该触发只执行一次，则行为执行完毕时触发废止**，后续也不再接受其他「允许触发」的唤醒；**若是重复触发，则行为执行结束后接着等待**（详见[循环结构](#_2-2-2-循环结构)）。而对于重复类型 1 - 所有满足，触发一次，情况则有点复杂。

对于地图上**预先摆着的实体，「所有满足，触发一次」就是字面意思**。好比我把指定的猴子全炸了，才出来一句「文体两开花」。但小队不同。
一个小队当中可以不止一个成员，同样一局游戏可以有好几批同种小队。

对于某**一批**小队里的**所有成员，「所有满足，触发一次」字面义同样适用**，也很容易理解；但对于**不同批次**的小队，**有多少批次触发就会执行多少次**，届时该触发实际上变成了重复触发。例子嘛，可以参考原版 RA2（不是尤里复仇）的盟军 11：核爆辐射尘，有一个经典的工程师修桥名场面。

#### 2.3.2 强制触发

强制触发仍然遵循触发时序的基本前提——这个触发未被「禁止」。对于一个被阻塞的触发，通过行为 22 - 强制触发 试图运行它，结果是什么都没有发生。也就是说，对于同一个被阻塞的触发，至少你需要先用行为 53 - 允许触发 将其唤醒，然后才紧接着 22 - 强制触发。

经测试，强制触发如我所猜测的那样，会忽略该触发的事件（组），直接运行触发行为。

### 2.4 引入局部变量后触发逻辑的变化
前面的分析都是基于触发系统本身，贴的代码也只是对假想条件和结果的调用。而在地图创作中，除了直接利用已有的条件库，还会用局部变量间接地做条件判断。为了讲清楚它如何参与到触发逻辑当中，不妨引入经典案例「运输船找妈妈」。

#### 2.4.1 案例实现思路
「运输船找妈妈」本质上就是让运载乘客的载具，**打哪来能回哪去**。我们观察一下 YR 苏军 01：时空转移的开局演出，易得流程如下：

- **满载**的运输船从地图外刷出，移动到定点；
- 等待所有乘客下船；
- **空载**的运输船从定点返回地图外。

难点就在于，如何得知**卸出乘客后船是空的**。翻看条件库，好像也没有类似的选项。  
于是我们设`apc unload`变量初始为 0，然后在运输船卸出乘客之后「设置局部变量」，触发得知「局部变量被设置」了，就建一个空船小队把它拉走。

> [!note]
> 篇幅原因，具体实现步骤我就不贴出来了。这种实用向教程应该也很容易找到。

#### 2.4.2 案例逻辑分析
我们已经知道这一经典例子中运用了局部变量，那么引入局部变量后触发逻辑有什么变化呢？

首先考虑局部变量的位置。从语义、代码语法上说，我们不可能未经定义就使用一个变量——好比解应用题，只设了未知数`x`却凭空跑出个`y`来。

在 FA2 的局部变量窗口中，你需要为局部变量起名（声明），然后 FA2 默认会令它等于 0（初始化，当然你可以改这个初始值）。那么这些局部变量保存到地图里肯定也是带着初始值的。  
这些局部变量最终又被引擎读进内存，组成数列（或者说数组）。所以，**在游戏开始之前，这些变量就已经就位了**。

那么我们不妨把局部变量放在程序代码的开头：
```python
apc_unload = 0  # 多数编程语言并不允许变量名带空格
if ...:
  ...
```
既然声明了局部变量，那么就要用起来。触发里有一组事件和一组结果分别读写局部变量（设待操作的局部变量为`x`）：

- 事件 36：（指定）局部变量被设定（值为 1），即当`x = 1`时
- 事件 37：（指定）局部变量被清除（0），即当`x = 0`时

* 行为 56：设置（指定）局部变量（值为 1），即令`x = 1`
* 行为 57：清除（指定）局部变量（值），即令`x = 0`

::: info 赋值与相等
在数学中描述等量关系用等号：当`a = 0`时，……。同时，赋值也用等号：令`x = 1`。  
而在编程中二者是不同的运算。为了避免混淆，你经常会看到用`==`指代相等，用`=`来赋值。
:::

那么上述案例便可以用如下伪代码表示：
```python
apc_unload = 0

if elapsedTime(20):
  playSpeech("EVA_ReinforcementsHaveArrived")
  spawnTeam("LCRFCome")

if apc_unload == 1:
  createTeam("LCRFBack")  # 4 - 建立小队
```

---

触发就是通过对局部变量值的变动，以实现一些较为复杂的逻辑判断。并且随着`int32`扩展局部变量的出现，触发的判断也不再局限于 0 和 1 的「左手倒右手」，而是与科技类型、超级武器、随机数等联系了起来，实现更加精细的随机机制和流程控制。

## 三、基本触发组件存在的问题

### 3.1 流程控制与逻辑运算局限性较大

从上面的分析中不难发现，红警 2 的触发只有顺序结构和循环结构相对直观，也恰恰为广大 mapper 所用。从历史的角度看，早期的任务流程简单、线性，翻看任务目标便一目了然；近年来才有应用分支流程，甚至为我们展现出「随机性」的优秀战役作品。由于触发的[选择结构](#_2-2-3-选择结构)并不像程序里的`if-elif`和`switch-case`那么清楚，作者们不得不花大量精力先考虑`else if`怎么做，更遑论利用状态机等经典设计做流程控制了。

另外，我们知道红警 2 条件判断只遵循逻辑「且」运算，「或」和「非」全部木大。这实际上为战役流程的设计又带来额外的困难——本来触发没有`else`已经够麻烦了。虽然从逻辑等价的角度来看也不是不能实现，但你毕竟不能指望多数中学牲 mapper 懂这些东西——他们或许还在为初等函数和解析几何发愁。

### 3.2 触发的事件和行为仍受引擎和扩展的限制

由于以前的逆向水平有限，RP、NP、NPExt 与其说是扩展平台，不如说是对`gamemd.exe`本身打补丁。并且当时的 mod 圈子更重视 INI 花活，很多 mod 遭遇战体系很成熟，但战役却莫得；就算是有，囿于认识不足和各种平台限制，表现效果也远不如今。

而 Ares、Phobos 等平台的出现，虽然标志着逆向程度更进一步，一定程度上也扩展了已有的触发库，但叙事如何设计还是得看平台脸色。若是平台没有轮子，地图师也不可能搞出「检测游戏目录下是否有`rules*.ini`，若有则游戏失败」这种反作弊来。

## 四、对上述问题的相关解决方案

### 4.1 通过局部变量实现「或」「非」逻辑运算

依据软硬件的逻辑等价性原理，触发确实可以做到或、非逻辑的判定。但显然，用累加去实现相乘，比起直接用乘法，总是麻烦得多。自行实现的或、非逻辑也一样。

#### 4.1.1 「或」运算——殊途同归
<!-- 假定我要办一场肉人运动会，锻炼下他们在战场的跑腿能力，设有 A、B 两个肉人选手。那么无论 A、B 谁到终点，比赛都会结束，对吧？

既然是运动会，自然终点线得是同一条，所以两条终点线、分别判定的选择结构方案显然被驳回了。这时候我们不妨考虑「触发的关联」，两个人都判断己方「进入事件」，然后通过关联触发链接在一起。

> [!tip]
> 你可以将触发以链式方式组织起来，以共享同一个关联对象（或「单元标记」划定的区域）。典型的例子是《尤里的复仇》盟军 03，那些被抢来抢去的电厂。
> 
> ::: details 具体来说，关联遵循如下规则……
> - 根触发作为**链头，绑定一切该关联的东西**。  
> 比如 YRA03，电厂首先有可能被盟军占领，那么对盟军的判定作为链头。
> - 其他触发则作为链节，**被**根触发关联。  
> 比如还是这个例子，电厂还有可能被尤里反占，但电厂上只能挂一个触发（标签），那就只能让链头（盟军判定）共享关联的电厂给它。
> - 链尾不绑定任何触发，也不许绑定根触发当作循环链表。  
> 问就是我不知道后果如何，有人想逝就试试。
> 
> ![奇怪的 Internal Error](./strange_fatal_error_msg.webp =40%x40%)
> :::
> 
> 总结起来就是谁去绑定实体，谁就是领头，要承担关联小弟触发的职责。若是「电厂>A>B>C」三触发关联，那么 B 既接受了 A 的共享**绑到了电厂**，同时要负起责任**把电厂共享给 C** 去绑定。


两边踩终点线的判定写完需要（各自）报胜利者，同时设置局部变量通知场外群演欢呼：
```c
bool cheers = 0;
if (Entered(A)) {
  ShowText("A won");
  cheers = 1;
}
if (Entered(B)) {
  ShowText("B won");
  cheers = 1;
}
// real cheers
if (cheers == 1) {
  Cheers(A);
  Cheers(B);
  ShowText("... 圆满结束致辞 ...");
  // blabla
}
```
可以看到，无论是哪一队踩到了终点线，整个「踩终点线」的条件组都会满足，也就相应执行起欢呼的流程。这就是「或」的精髓——一真皆真。 -->

#### 4.1.2 「非」运算——逆向思维

<!-- 与上述「或」运算的实现不同，触发事件的「非」运算需要借助原条件。

举个例子，游戏里基洛夫飞艇飞得比较慢，我们就假定它要送~~外卖（大嘘）~~ 炸弹吧。要求指定时间内摧毁目标。
那么对于基洛夫要判断两件事：

- 计时器没超时（流逝时间小于指定值）
- 摧毁目标

翻译过来就是`ObjectDestroyed(target) and not TimeElapsed(max))`。

我们首先假定它超时了，超时就任务失败嘛。那么它原本应该是能完成任务的。所以伪代码这么写：
```c
// 我的变量名取「及时」的语义，代表任务初始可以完成
bool mission_in_time = true;
if (TimeElapsed(max))   mission_in_time = false;
if (mission_in_time == 1 and ObjectDestroyed(target)) {
  // blabla
}
```
这样一来，触发通过判断原条件「已经过了指定时间」成立，反向推出「仍在指定时间内」这一条件不成立，实现了对「超时」的判断。  
总之，我们可以借助局部变量的`bool`开关特性，将判断「条件的否定」分解为「判断条件」和「给条件取反」两个步骤，
并用局部变量将「条件的否定」带给其他触发，间接完成条件的「非」运算。 -->

### 4.2 通过脚本语言等方式对游戏作更全面的干预

这个路线圈子里已经有大佬这么尝试了，我毕竟也没什么编程和逆向水平，恕不做过多展开了。

简单来说，可以用一些脚本化的语言作为「干预」的载体，并且根据现有逆向成果尝试为脚本提供接口，通过 Hook 等方式试图调用脚本来干预`gamemd.exe`的运行（以聚哈的 DynamicPatcher 为代表）；更进一步地，可以在引擎中集成 console（类似 Minecraft 的控制台命令），以更实时的方式干预游戏进程。

## 结论

综上所述，红警 2 的触发在逻辑层面上类似`if`单分支语句的设计，支持顺序、选择、循环三种结构，可以实现大部分任务所需的线性叙事。然而其在逻辑运算上又有所欠缺，导致要追求完整的逻辑判断要通过局部变量绕路实现，对于地图师的逻辑思维能力是一大考验。

并且，随着时代变迁，触发的客制化需求也与日俱增，人们已经不再满足于扩展平台炒的大锅饭，开始转向脚本式的外部干预。但截至 24.6.17 尚没有公开、可行的相应方案。

综上所述，红警 2 对剧情表现的探索仍有很长的路要走。

## 参考文献

1. ModEnc. [Triggers](https://modenc.renegadeprojects.com/Triggers) \[EB/OL\], 1.31.2024, 6.17.2024.
2. ModEnc. [VariableNames](https://modenc.renegadeprojects.com/VariableNames) \[EB/OL\], 5.16.2024, 6.17.2024.
3. ModEnc. [Tags](https://modenc.renegadeprojects.com/Tags) \[EB/OL\], 1.31.2024, 11.14.2024.
4. RN Studio. [map_tutorial](https://github.com/revengenowstudio/map_tutorial) \[EB/OL\], 4.29.2024, 5.6.2024.

> [!NOTE]
> 便利起见，文献附注格式基于 GB/T 7714 规范作了简化。

## 致谢

时光荏苒，距离我最开始做大白板雪原、遭遇战一样的战役地图应该也有九个年头了。能够写到这里，全拜各位大佬、同行、玩家朋友所赐。Lin 在此谢过诸位。

首先，感谢 RN Studio 指导我的「实验」。感谢制作组的地图教程，为我的「选题」指引方向；感谢 Zero Fanker 等人提出的指导和改进意见，以及底层实现上的补充、佐证和更正。

其次，感谢曾经与仍在为红警 2 模组创作贡献智慧的各路人才，为我的论证提供各种帮助。特别感谢地图师同行们对触发系统所作的各种实地测试和表述修订，同时感谢 Phobos 团队开源触发组件的扩展实现，以及 Heli 等人为简化地图开发所做的各种尝试。

最后，感谢各位喜爱战役的红红玩家，特别是「星辰之光」的测试员和玩家朋友们，愿意拨冗测试、体验我参与制作的战役关卡。能够在涉足过的此岸留下一抹自己的足迹，我深感荣幸。
