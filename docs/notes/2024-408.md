---
tag:
  - 考研
---

# 408 个人备考心得（2024 年版）

> [!important]
> 之所以强调“24 年版”，是因为每年的考点侧重都略有不同，我的心得实际上有相当一部分**可能已经过时**。
> 写这一篇随记，不过是回忆下往昔。

## 零、总览
我个人是从会计学跨考去计算机专硕（很抽象吧？兴趣使然罢了），平日对于编程也不过是浅尝辄止的业余，如若不是学了 408，我可能也不过是会稍微折腾折腾 Windows 系统的计算机原始人罢了。

那年考研我死在了数学。~~数学，一生之敌。~~ 哪怕是最简单的数二，我也依旧取得了 22 分的招笑成绩，非常之“二”。虽然其他三科看起来还可以吧（政治75英二69四零八93），但很可惜国家线对每一科都有分数要求，数学炸了别的考再好都没有用。

好了，不痛苦面具了。首先总的讲讲其余三科我怎么应对的吧。

整个考研备考，在我看来大概分为前后两阶段。前期总体而言就是年初到暑假的复习阶段（或者对我来说是自学阶段，毕竟跨考壬没学过 408）；后期就基本上在“运用这些知识点”，通俗点讲就是在刷题了。当然具体到每一科、读者们的实际情况而言，侧重点会略有不同吧。

- 英语II：前期多背单词，后期刷真题就彳亍了。所谓模拟题没什么必要碰，真题已经足够你总结出各种题型的经验了。
> 我英二和 CET-6 同时备考的（因为大二看同学在做真题竟发现看不懂，弃了一学年），所以基本上在背 CET-6 的词库（据说考研英语词汇量要求比六级少）。对于单词我始终是“实用主义”——**语言就是拿来用的**。背单词理解释义之后，不妨造造句把它们用起来。平时甚至可以考虑把手机、电脑的系统语言切换成英语，在实际的语境中推断这些词的意思。  
> 至于解题思路，还是那些废话吧：*完形结合上下文，阅读（和七选五）带着问题（或者关键词）去文中找答案，翻译直译都没关系，作文就不赘述了*。完形和阅读都比较考验词汇量，并且比起六级误导信息更多，很容易踩坑。

- 政治：不用操之过急，三月份那些卖课老师们还在眼巴巴望着两会呢。后期（暑假）开始复习都可以。
> 马哲多亏父上喜欢讨论哲学，耳濡目染之下还算比较简单。不懂的话可以试试用马哲去分析生活琐事，或许看问题会发现不一样的视角（  
> 史纲把握时间线就好了，重点在于这些历史事件发生的**主客观条件**以及**历史意义**。  
> 思修抓重点背就好了（个人与社会的关系，.etc）  
> 毛习概比较麻烦。毛思想还好，你仔细看他提出来这些路线方针，结合史纲很容易找到他这些政治话语的历史依据。但是习大大新思想就好难背，每一条都不止一行（

- 408：也是**多做真题**。去看看真题都考什么、哪些考点应对不来、哪些考点会做但还可以改进，抓住主要矛盾了再刷刷看相对冷门的考点查漏补缺。

## 一、关于四零八
408 的官方名称是**计算机学科专业基础综合**，因为其科目代码为 408，大部分情况下也就这么简称。其包含：

- 数据结构（Data Structure，DS）
- 计算机组成原理
- 计算机网络
- 操作系统（Operating System，OS）

这四门课。当然**有些学校是自命题**，只考其中的一科或几科；或者有的干脆另起炉灶，自己冠个名。还有一些学校会考**信号与系统**，那就不是本篇的讨论范围了。

我是先从数据结构开始学起，毕竟它最接近我实际写代码的情景。  
其次是寄组和操作系统两科，没错是同时复习。因为寄组的“存储系统”和操作系统“进程的内存管理”实际上恰好能拼成完整的数据交换通路（CPU Cache—RAM—硬盘），完整地理解整个存储管理系统可以很方便地去应对寄组和操作系统在这方面的大题（像操作系统有些题干可能直接借用寄组那边的）。  
最后是寄网，这块说实话确实是寄，直接看王道论坛的计网视频课说实话并不适合我。初学建议结合[湖科大教书匠的计网微课堂](https://www.bilibili.com/video/BV1c4411d7jb)一起食用，先看湖科大的打个底，然后看看王道课进阶，交替食用或许好理解一点。

试题内容是严格按照**数据结构—寄组—操作系统—寄网**排列的：
- 选择题 1-11：数据结构
- 12-22：寄组
- 23-32：操作系统
- 33-40：寄网

* 大题 41-42：数据结构
* 43-45：寄组、操作系统（汇编、存储管理）
* 46：操作系统（PV 原语）
* 47：寄网

我个人的经验是，如果光看题干看不懂，那就画图。草稿纸记得留一页（没错一页）写代码，因为卷面整洁嘛。

## 二、数据结构
这块基本上也没什么特别的，简单的甚至可以手搓接口和子类实现；而像 BST（二叉排序树）、红黑树又不好考你代码，只能是概念大题（42）或者选择题让你当肉编器了。

### 复杂度
::: note 算法的有穷性
首先在这里补充一点，因为之前做题有过理解偏差。我们说算法必须在有穷步、有穷时间内结束，这个“有穷”是对人类有意义的限度。一个循环可能执行数百万次，执行到我们忍不住`taskkill /f /im test.exe`，那这种循环在试题当中**仍然认为是死循环**。
:::

复杂度说白了就是一种预估。给定一组总数为 $n$ 的数据，你对这些数据的操作**预计**执行 $n$ 次、$n^2$ 次、$\log{n}$ 次，这叫**时间复杂度**，记 $T(n)$。你的操作预计要申请多大片内存，$4n$、$n!$、还是常数 $O(1)$？这叫**空间复杂度**，记 $S(n)$。

复杂度计算遵循最大量级优先（加法法则）和乘法法则：
- 最大量级优先：$T(n) = O(f_1(n)) + O(f_2(n)) = O(max(f_1, f_2))$

> 你的确可以将不同语句的复杂度累加起来，但主要矛盾、真正最显著的项永远是最大量级那个复杂度。

- 乘法法则：$T(n) = O(f_1(n)) \times O(f_2(n)) = O(f_1 \cdot f_2)$

- 常见的复杂度排序：  
    $$ O(1) < O(\log{n}) < O(n) < O(n\log{n}) < O(n^2) < O(n^3)
     < O(2^n) < O(n!) < O(n^n) $$

判断时间复杂度，比较显著的标志是循环。考虑以下代码片段：
```
cnt = 0
for (int k = 1; k <= n; k *= 2)
    for (int j = 1; j <= n; j++)
        count++
```
`k`的递进是 1、2、4，可以看出是指数函数。但在总数为 $n$ 的数据范围内，这么大跨步只会访问到 $\log_2{n}$ 个项；`j`则是从头数到尾，显著的 $O(n)$。由于是套娃循环，`k`每走一次`j`就要走 $n$ 次，所以最终循环走 $n\log{n}$ 次，即 $T(n) = O(n\log{n})$。

判断空间复杂度，比较显著的标志是递归（函数调用栈的深度）和辅助数据结构（比如临时数组）。

### 线性表
线性表，顾名思义，线性组织数据的表。注意这种“线性组织”是逻辑上线性，实际在进程里可能并不“线性”。大学刚接触的线性表可能就数组或者链表：
```c
char a[114514];

typedef struct __node {
    int data;
    struct __node *next;
} ChainNode, *ChainList;
```
对于一个线性表，我们容易想到基本的增删查改，大概就是这样的接口：
```c#
public interface ILinear<T> {
    public bool Add(T element);
    public void Insert(int indexOrCount, T element);  // 链表也可能在中间插入
    public bool Remove(T element);
    public bool RemoveAt(int indexOrCount);  // 链表也可能要删*第几个*元素的喵
    public T this[int index] { get; set; }  // 按下标（或者序数，第几个）读写访问
    public void Clear();  // 清空表
    public bool IsEmpty();
    public bool IsFull();
    public int Count();
}
```
无论数组、链表、栈、队列，在逻辑上都是线性排列的，也就是继承自`ILinear`；你可以\*部分\*实现这些接口，去实现一个自己的序列存储。当然我知道自己写的肯定不如标准库高性能，但自己实际地去写这些代码，乃至用调试器一步步跑着你写的代码，会让你对这些结构印象更深刻。

### 数组的特殊运用——矩阵的压缩存储
我们知道数组是连续存储的，二维数组同样。考虑一个 5 阶矩阵（摘自我的复习笔记，随便拟的）：
$$
\begin{bmatrix}
   0 & 2 & 3 & 7 & 2 \\
   2 & 0 & 1 & 11 & 4 \\
   3 & 1 & 0 & 0 & 8 \\
   7 & 11 & 0 & 0 & 9 \\
   2 & 4 & 8 & 9 & 0
\end{bmatrix}
$$
我们注意到主对角线两边的元素是对称的，那就意味着把整个矩阵都存进二维数组会因重复项导致空间浪费。有没有可能把它压缩存成一维数组捏？有的兄弟，有的。

#### 向上三角压缩，行优先表示
以上三角为例，我们可以逐行地填入数组 B 中：

![行优先数组表示](./matrix_compression_line-based.webp)

但这么一来，我们就需要建立 $(i, j)$ 行列坐标（其中 $i, j \in [0, 4]$）到数组下标的映射。假设我要求 2 行 4 列那个“8”的下标，那据上面那个数组表格我们能知道是 11，但假如这个矩阵足够大呢？你还要画好长好长的数组图吗？当然没有必要。

稍微数一下矩阵可以发现，在第 2 行前面共有 2 行（谨记 i 从 0 开始），这两行共计 $5+4=9$ 个元素。那么以此类推，第 i 行前面那 i 行共计
$$
n + (n - 1) + ... + (n - i) = ni - \frac{i(i - 1)}{2}
$$
个元素。而在第 2 行内，$a_{24}$ 前还有 2 个元素，类推到第 i 行内，$a_{ij}$ 前尚有 $j - i$ 个元素。于是有
$$
a_{ij} = a_{ji} = B[ni - \frac{i(i - 1)}{2} + j - i]
$$
以 $(2, 4)$ 为例，$a_{2,4} = B[10 - 1 + 4 - 2] = B[11] = 8$.

#### 向上三角压缩，列优先表示
仍然画出数组图，设数组为 D：

![列优先数组表示](./matrix_compression_col-based.webp)

仍然“稍微数一下”。在第 4 列之前共有 4 列（谨记 j 也从 0 开始），共计
$$
1+2+...+j = \frac{j(j+1)}{2}
$$
个元素。而在第 4 列中，$a_{24}$ 之上，共有 i 行 i 个元素。
$$
\therefore a_{ij} = a_{ji} = D[\frac{j(j+1)}{2} + i].
$$
仍以 $(2, 4)$ 为例，$D[\frac{4(4+1)}{2} + 2] = D[12] = a_{2,4} = 8$.

> [!warning]
> 施工中喵。
